# 知识点
1. atomicAdd是原子加法，同类型原子操作有很多，比如减法等等
2. 输出的数组需要预先分配空间，例如这里的：output_capacity
3. 最后统计结果的时候记得取min，int output_size = min(output_host[0], output_capacity);
    - 因为核函数中，add的次数可能会超过capacity大小，导致后续访问越界的发生
4. 输出的数组可能会乱序，即不同执行时刻结果不同。这是因为cuda是并行的，调度器的调度顺序不确定
    - 因此capacity一定要比预期的最大值大一些，才可能保证结果不会丢失
    - 可以通过储存index，然后在cpu上执行一次排序，实现最后是输出是有序的
5. 这种类型的代码实现，是模型后处理的关键，处理动态数组的关键